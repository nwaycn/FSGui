<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>System Information Functions</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.5.4 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="Functions and Operators"
HREF="functions.html"><LINK
REL="PREVIOUS"
TITLE="Set Returning Functions"
HREF="functions-srf.html"><LINK
REL="NEXT"
TITLE="System Administration Functions"
HREF="functions-admin.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=ISO-8859-1"><META
NAME="creation"
CONTENT="2016-08-08T20:44:24"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.5.4 Documentation</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Set Returning Functions"
HREF="functions-srf.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="functions.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Chapter 9. Functions and Operators</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="System Administration Functions"
HREF="functions-admin.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="FUNCTIONS-INFO"
>9.25. System Information Functions</A
></H1
><P
>   <A
HREF="functions-info.html#FUNCTIONS-INFO-SESSION-TABLE"
>Table 9-57</A
> shows several
   functions that extract session and system information.
  </P
><P
>   In addition to the functions listed in this section, there are a number of
   functions related to the statistics system that also provide system
   information. See <A
HREF="monitoring-stats.html#MONITORING-STATS-VIEWS"
>Section 27.2.2</A
> for more
   information.
  </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-INFO-SESSION-TABLE"
></A
><P
><B
>Table 9-57. Session Information Functions</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>Name</TH
><TH
>Return Type</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>current_catalog</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>name of current database (called <SPAN
CLASS="QUOTE"
>"catalog"</SPAN
> in the SQL standard)</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>current_database()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>name of current database</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>current_query()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>text of the currently executing query, as submitted
       by the client (might contain more than one statement)</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>current_schema</CODE
>[()]</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>name of current schema</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>current_schemas(<TT
CLASS="TYPE"
>boolean</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>name[]</TT
></TD
><TD
>names of schemas in search path, optionally including implicit schemas</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>current_user</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>user name of current execution context</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>inet_client_addr()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>inet</TT
></TD
><TD
>address of the remote connection</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>inet_client_port()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>int</TT
></TD
><TD
>port of the remote connection</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>inet_server_addr()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>inet</TT
></TD
><TD
>address of the local connection</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>inet_server_port()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>int</TT
></TD
><TD
>port of the local connection</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_backend_pid()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>int</TT
></TD
><TD
>        Process ID of the server process attached to the current session
       </TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_conf_load_time()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>configuration load time</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_is_other_temp_schema(<TT
CLASS="TYPE"
>oid</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>is schema another session's temporary schema?</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_listening_channels()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>setof text</TT
></TD
><TD
>channel names that the session is currently listening on</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_my_temp_schema()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>OID of session's temporary schema, or 0 if none</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_postmaster_start_time()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>server start time</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_trigger_depth()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>int</TT
></TD
><TD
>current nesting level of <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> triggers
       (0 if not called, directly or indirectly, from inside a trigger)</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>session_user</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>session user name</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>user</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>equivalent to <CODE
CLASS="FUNCTION"
>current_user</CODE
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>version()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> version information. See also <A
HREF="runtime-config-preset.html#GUC-SERVER-VERSION-NUM"
>server_version_num</A
> for a machine-readable version.</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>     <CODE
CLASS="FUNCTION"
>current_catalog</CODE
>, <CODE
CLASS="FUNCTION"
>current_schema</CODE
>,
     <CODE
CLASS="FUNCTION"
>current_user</CODE
>, <CODE
CLASS="FUNCTION"
>session_user</CODE
>,
     and <CODE
CLASS="FUNCTION"
>user</CODE
> have special syntactic status
     in <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>: they must be called without trailing
     parentheses.  (In PostgreSQL, parentheses can optionally be used with
     <CODE
CLASS="FUNCTION"
>current_schema</CODE
>, but not with the others.)
    </P
></BLOCKQUOTE
></DIV
><P
>    The <CODE
CLASS="FUNCTION"
>session_user</CODE
> is normally the user who initiated
    the current database connection; but superusers can change this setting
    with <A
HREF="sql-set-session-authorization.html"
>SET SESSION AUTHORIZATION</A
>.
    The <CODE
CLASS="FUNCTION"
>current_user</CODE
> is the user identifier
    that is applicable for permission checking. Normally it is equal
    to the session user, but it can be changed with
    <A
HREF="sql-set-role.html"
>SET ROLE</A
>.
    It also changes during the execution of
    functions with the attribute <TT
CLASS="LITERAL"
>SECURITY DEFINER</TT
>.
    In Unix parlance, the session user is the <SPAN
CLASS="QUOTE"
>"real user"</SPAN
> and
    the current user is the <SPAN
CLASS="QUOTE"
>"effective user"</SPAN
>.
   </P
><P
>    <CODE
CLASS="FUNCTION"
>current_schema</CODE
> returns the name of the schema that is
    first in the search path (or a null value if the search path is
    empty).  This is the schema that will be used for any tables or
    other named objects that are created without specifying a target schema.
    <CODE
CLASS="FUNCTION"
>current_schemas(boolean)</CODE
> returns an array of the names of all
    schemas presently in the search path.  The Boolean option determines whether or not
    implicitly included system schemas such as <TT
CLASS="LITERAL"
>pg_catalog</TT
> are included in the
    returned search path.
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>     The search path can be altered at run time.  The command is:
</P><PRE
CLASS="PROGRAMLISTING"
>SET search_path TO <TT
CLASS="REPLACEABLE"
><I
>schema</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>, <TT
CLASS="REPLACEABLE"
><I
>schema</I
></TT
>, ...</SPAN
>]</PRE
><P>
    </P
></BLOCKQUOTE
></DIV
><P
>    <CODE
CLASS="FUNCTION"
>pg_listening_channels</CODE
> returns a set of names of
    channels that the current session is listening to.  See <A
HREF="sql-listen.html"
>LISTEN</A
> for more information.
   </P
><P
>     <CODE
CLASS="FUNCTION"
>inet_client_addr</CODE
> returns the IP address of the
     current client, and <CODE
CLASS="FUNCTION"
>inet_client_port</CODE
> returns the
     port number.
     <CODE
CLASS="FUNCTION"
>inet_server_addr</CODE
> returns the IP address on which
     the server accepted the current connection, and
     <CODE
CLASS="FUNCTION"
>inet_server_port</CODE
> returns the port number.
     All these functions return NULL if the current connection is via a
     Unix-domain socket.
   </P
><P
>    <CODE
CLASS="FUNCTION"
>pg_my_temp_schema</CODE
> returns the OID of the current
    session's temporary schema, or zero if it has none (because it has not
    created any temporary tables).
    <CODE
CLASS="FUNCTION"
>pg_is_other_temp_schema</CODE
> returns true if the
    given OID is the OID of another session's temporary schema.
    (This can be useful, for example, to exclude other sessions' temporary
    tables from a catalog display.)
   </P
><P
>    <CODE
CLASS="FUNCTION"
>pg_postmaster_start_time</CODE
> returns the
    <TT
CLASS="TYPE"
>timestamp with time zone</TT
> when the
    server started.
   </P
><P
>    <CODE
CLASS="FUNCTION"
>pg_conf_load_time</CODE
> returns the
    <TT
CLASS="TYPE"
>timestamp with time zone</TT
> when the
    server configuration files were last loaded.
    (If the current session was alive at the time, this will be the time
    when the session itself re-read the configuration files, so the
    reading will vary a little in different sessions.  Otherwise it is
    the time when the postmaster process re-read the configuration files.)
   </P
><P
>    <CODE
CLASS="FUNCTION"
>version</CODE
> returns a string describing the
    <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> server's version. You can also
    get this information from <A
HREF="runtime-config-preset.html#GUC-SERVER-VERSION"
>server_version</A
> or
    for a machine-readable version, <A
HREF="runtime-config-preset.html#GUC-SERVER-VERSION-NUM"
>server_version_num</A
>.
    Software developers should use <TT
CLASS="LITERAL"
>server_version_num</TT
>
    (available since 8.2) or <A
HREF="libpq-status.html#LIBPQ-PQSERVERVERSION"
><I
CLASS="TERM"
>      <CODE
CLASS="FUNCTION"
>PQserverVersion</CODE
>
      
     </I
></A
> instead
    of parsing the text version.
   </P
><P
>   <A
HREF="functions-info.html#FUNCTIONS-INFO-ACCESS-TABLE"
>Table 9-58</A
> lists functions that
   allow the user to query object access privileges programmatically.
   See <A
HREF="ddl-priv.html"
>Section 5.6</A
> for more information about
   privileges.
  </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-INFO-ACCESS-TABLE"
></A
><P
><B
>Table 9-58. Access Privilege Inquiry Functions</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>Name</TH
><TH
>Return Type</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>has_any_column_privilege</CODE
>(<TT
CLASS="PARAMETER"
>user</TT
>,
                                  <TT
CLASS="PARAMETER"
>table</TT
>,
                                  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>does user have privilege for any column of table</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>has_any_column_privilege</CODE
>(<TT
CLASS="PARAMETER"
>table</TT
>,
                                  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>does current user have privilege for any column of table</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>has_column_privilege</CODE
>(<TT
CLASS="PARAMETER"
>user</TT
>,
                                  <TT
CLASS="PARAMETER"
>table</TT
>,
                                  <TT
CLASS="PARAMETER"
>column</TT
>,
                                  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>does user have privilege for column</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>has_column_privilege</CODE
>(<TT
CLASS="PARAMETER"
>table</TT
>,
                                  <TT
CLASS="PARAMETER"
>column</TT
>,
                                  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>does current user have privilege for column</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>has_database_privilege</CODE
>(<TT
CLASS="PARAMETER"
>user</TT
>,
                                  <TT
CLASS="PARAMETER"
>database</TT
>,
                                  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>does user have privilege for database</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>has_database_privilege</CODE
>(<TT
CLASS="PARAMETER"
>database</TT
>,
                                  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>does current user have privilege for database</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>has_foreign_data_wrapper_privilege</CODE
>(<TT
CLASS="PARAMETER"
>user</TT
>,
                                  <TT
CLASS="PARAMETER"
>fdw</TT
>,
                                  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>does user have privilege for foreign-data wrapper</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>has_foreign_data_wrapper_privilege</CODE
>(<TT
CLASS="PARAMETER"
>fdw</TT
>,
                                  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>does current user have privilege for foreign-data wrapper</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>has_function_privilege</CODE
>(<TT
CLASS="PARAMETER"
>user</TT
>,
                                  <TT
CLASS="PARAMETER"
>function</TT
>,
                                  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>does user have privilege for function</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>has_function_privilege</CODE
>(<TT
CLASS="PARAMETER"
>function</TT
>,
                                  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>does current user have privilege for function</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>has_language_privilege</CODE
>(<TT
CLASS="PARAMETER"
>user</TT
>,
                                  <TT
CLASS="PARAMETER"
>language</TT
>,
                                  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>does user have privilege for language</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>has_language_privilege</CODE
>(<TT
CLASS="PARAMETER"
>language</TT
>,
                                  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>does current user have privilege for language</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>has_schema_privilege</CODE
>(<TT
CLASS="PARAMETER"
>user</TT
>,
                                  <TT
CLASS="PARAMETER"
>schema</TT
>,
                                  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>does user have privilege for schema</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>has_schema_privilege</CODE
>(<TT
CLASS="PARAMETER"
>schema</TT
>,
                                  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>does current user have privilege for schema</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>has_sequence_privilege</CODE
>(<TT
CLASS="PARAMETER"
>user</TT
>,
                                  <TT
CLASS="PARAMETER"
>sequence</TT
>,
                                  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>does user have privilege for sequence</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>has_sequence_privilege</CODE
>(<TT
CLASS="PARAMETER"
>sequence</TT
>,
                                  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>does current user have privilege for sequence</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>has_server_privilege</CODE
>(<TT
CLASS="PARAMETER"
>user</TT
>,
                                  <TT
CLASS="PARAMETER"
>server</TT
>,
                                  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>does user have privilege for foreign server</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>has_server_privilege</CODE
>(<TT
CLASS="PARAMETER"
>server</TT
>,
                                  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>does current user have privilege for foreign server</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>has_table_privilege</CODE
>(<TT
CLASS="PARAMETER"
>user</TT
>,
                                  <TT
CLASS="PARAMETER"
>table</TT
>,
                                  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>does user have privilege for table</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>has_table_privilege</CODE
>(<TT
CLASS="PARAMETER"
>table</TT
>,
                                  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>does current user have privilege for table</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>has_tablespace_privilege</CODE
>(<TT
CLASS="PARAMETER"
>user</TT
>,
                                  <TT
CLASS="PARAMETER"
>tablespace</TT
>,
                                  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>does user have privilege for tablespace</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>has_tablespace_privilege</CODE
>(<TT
CLASS="PARAMETER"
>tablespace</TT
>,
                                  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>does current user have privilege for tablespace</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_has_role</CODE
>(<TT
CLASS="PARAMETER"
>user</TT
>,
                                  <TT
CLASS="PARAMETER"
>role</TT
>,
                                  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>does user have privilege for role</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_has_role</CODE
>(<TT
CLASS="PARAMETER"
>role</TT
>,
                                  <TT
CLASS="PARAMETER"
>privilege</TT
>)</TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>does current user have privilege for role</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>row_security_active</CODE
>(<TT
CLASS="PARAMETER"
>table</TT
>)</TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>does current user have row level security active for table</TD
></TR
></TBODY
></TABLE
></DIV
><P
>    <CODE
CLASS="FUNCTION"
>has_table_privilege</CODE
> checks whether a user
    can access a table in a particular way.  The user can be
    specified by name, by OID (<TT
CLASS="LITERAL"
>pg_authid.oid</TT
>),
    <TT
CLASS="LITERAL"
>public</TT
> to indicate the PUBLIC pseudo-role, or if the argument is
    omitted
    <CODE
CLASS="FUNCTION"
>current_user</CODE
> is assumed.  The table can be specified
    by name or by OID.  (Thus, there are actually six variants of
    <CODE
CLASS="FUNCTION"
>has_table_privilege</CODE
>, which can be distinguished by
    the number and types of their arguments.)  When specifying by name,
    the name can be schema-qualified if necessary.
    The desired access privilege type
    is specified by a text string, which must evaluate to one of the
    values <TT
CLASS="LITERAL"
>SELECT</TT
>, <TT
CLASS="LITERAL"
>INSERT</TT
>,
    <TT
CLASS="LITERAL"
>UPDATE</TT
>, <TT
CLASS="LITERAL"
>DELETE</TT
>, <TT
CLASS="LITERAL"
>TRUNCATE</TT
>,
    <TT
CLASS="LITERAL"
>REFERENCES</TT
>, or <TT
CLASS="LITERAL"
>TRIGGER</TT
>.  Optionally,
    <TT
CLASS="LITERAL"
>WITH GRANT OPTION</TT
> can be added to a privilege type to test
    whether the privilege is held with grant option.  Also, multiple privilege
    types can be listed separated by commas, in which case the result will
    be <TT
CLASS="LITERAL"
>true</TT
> if any of the listed privileges is held.
    (Case of the privilege string is not significant, and extra whitespace
    is allowed between but not within privilege names.)
    Some examples:
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT has_table_privilege('myschema.mytable', 'select');
SELECT has_table_privilege('joe', 'mytable', 'INSERT, SELECT WITH GRANT OPTION');</PRE
><P>
   </P
><P
>    <CODE
CLASS="FUNCTION"
>has_sequence_privilege</CODE
> checks whether a user
    can access a sequence in a particular way.  The possibilities for its
    arguments are analogous to <CODE
CLASS="FUNCTION"
>has_table_privilege</CODE
>.
    The desired access privilege type must evaluate to one of
    <TT
CLASS="LITERAL"
>USAGE</TT
>,
    <TT
CLASS="LITERAL"
>SELECT</TT
>, or
    <TT
CLASS="LITERAL"
>UPDATE</TT
>.
   </P
><P
>    <CODE
CLASS="FUNCTION"
>has_any_column_privilege</CODE
> checks whether a user can
    access any column of a table in a particular way.
    Its argument possibilities
    are analogous to <CODE
CLASS="FUNCTION"
>has_table_privilege</CODE
>,
    except that the desired access privilege type must evaluate to some
    combination of
    <TT
CLASS="LITERAL"
>SELECT</TT
>,
    <TT
CLASS="LITERAL"
>INSERT</TT
>,
    <TT
CLASS="LITERAL"
>UPDATE</TT
>, or
    <TT
CLASS="LITERAL"
>REFERENCES</TT
>.  Note that having any of these privileges
    at the table level implicitly grants it for each column of the table,
    so <CODE
CLASS="FUNCTION"
>has_any_column_privilege</CODE
> will always return
    <TT
CLASS="LITERAL"
>true</TT
> if <CODE
CLASS="FUNCTION"
>has_table_privilege</CODE
> does for the same
    arguments.  But <CODE
CLASS="FUNCTION"
>has_any_column_privilege</CODE
> also succeeds if
    there is a column-level grant of the privilege for at least one column.
   </P
><P
>    <CODE
CLASS="FUNCTION"
>has_column_privilege</CODE
> checks whether a user
    can access a column in a particular way.
    Its argument possibilities
    are analogous to <CODE
CLASS="FUNCTION"
>has_table_privilege</CODE
>,
    with the addition that the column can be specified either by name
    or attribute number.
    The desired access privilege type must evaluate to some combination of
    <TT
CLASS="LITERAL"
>SELECT</TT
>,
    <TT
CLASS="LITERAL"
>INSERT</TT
>,
    <TT
CLASS="LITERAL"
>UPDATE</TT
>, or
    <TT
CLASS="LITERAL"
>REFERENCES</TT
>.  Note that having any of these privileges
    at the table level implicitly grants it for each column of the table.
   </P
><P
>    <CODE
CLASS="FUNCTION"
>has_database_privilege</CODE
> checks whether a user
    can access a database in a particular way.
    Its argument possibilities
    are analogous to <CODE
CLASS="FUNCTION"
>has_table_privilege</CODE
>.
    The desired access privilege type must evaluate to some combination of
    <TT
CLASS="LITERAL"
>CREATE</TT
>,
    <TT
CLASS="LITERAL"
>CONNECT</TT
>,
    <TT
CLASS="LITERAL"
>TEMPORARY</TT
>, or
    <TT
CLASS="LITERAL"
>TEMP</TT
> (which is equivalent to
    <TT
CLASS="LITERAL"
>TEMPORARY</TT
>).
   </P
><P
>    <CODE
CLASS="FUNCTION"
>has_function_privilege</CODE
> checks whether a user
    can access a function in a particular way.
    Its argument possibilities
    are analogous to <CODE
CLASS="FUNCTION"
>has_table_privilege</CODE
>.
    When specifying a function by a text string rather than by OID,
    the allowed input is the same as for the <TT
CLASS="TYPE"
>regprocedure</TT
> data type
    (see <A
HREF="datatype-oid.html"
>Section 8.18</A
>).
    The desired access privilege type must evaluate to
    <TT
CLASS="LITERAL"
>EXECUTE</TT
>.
    An example is:
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');</PRE
><P>
   </P
><P
>    <CODE
CLASS="FUNCTION"
>has_foreign_data_wrapper_privilege</CODE
> checks whether a user
    can access a foreign-data wrapper in a particular way.
    Its argument possibilities
    are analogous to <CODE
CLASS="FUNCTION"
>has_table_privilege</CODE
>.
    The desired access privilege type must evaluate to
    <TT
CLASS="LITERAL"
>USAGE</TT
>.
   </P
><P
>    <CODE
CLASS="FUNCTION"
>has_language_privilege</CODE
> checks whether a user
    can access a procedural language in a particular way.
    Its argument possibilities
    are analogous to <CODE
CLASS="FUNCTION"
>has_table_privilege</CODE
>.
    The desired access privilege type must evaluate to
    <TT
CLASS="LITERAL"
>USAGE</TT
>.
   </P
><P
>    <CODE
CLASS="FUNCTION"
>has_schema_privilege</CODE
> checks whether a user
    can access a schema in a particular way.
    Its argument possibilities
    are analogous to <CODE
CLASS="FUNCTION"
>has_table_privilege</CODE
>.
    The desired access privilege type must evaluate to some combination of
    <TT
CLASS="LITERAL"
>CREATE</TT
> or
    <TT
CLASS="LITERAL"
>USAGE</TT
>.
   </P
><P
>    <CODE
CLASS="FUNCTION"
>has_server_privilege</CODE
> checks whether a user
    can access a foreign server in a particular way.
    Its argument possibilities
    are analogous to <CODE
CLASS="FUNCTION"
>has_table_privilege</CODE
>.
    The desired access privilege type must evaluate to
    <TT
CLASS="LITERAL"
>USAGE</TT
>.
   </P
><P
>    <CODE
CLASS="FUNCTION"
>has_tablespace_privilege</CODE
> checks whether a user
    can access a tablespace in a particular way.
    Its argument possibilities
    are analogous to <CODE
CLASS="FUNCTION"
>has_table_privilege</CODE
>.
    The desired access privilege type must evaluate to
    <TT
CLASS="LITERAL"
>CREATE</TT
>.
   </P
><P
>    <CODE
CLASS="FUNCTION"
>pg_has_role</CODE
> checks whether a user
    can access a role in a particular way.
    Its argument possibilities
    are analogous to <CODE
CLASS="FUNCTION"
>has_table_privilege</CODE
>,
    except that <TT
CLASS="LITERAL"
>public</TT
> is not allowed as a user name.
    The desired access privilege type must evaluate to some combination of
    <TT
CLASS="LITERAL"
>MEMBER</TT
> or
    <TT
CLASS="LITERAL"
>USAGE</TT
>.
    <TT
CLASS="LITERAL"
>MEMBER</TT
> denotes direct or indirect membership in
    the role (that is, the right to do <TT
CLASS="COMMAND"
>SET ROLE</TT
>), while
    <TT
CLASS="LITERAL"
>USAGE</TT
> denotes whether the privileges of the role
    are immediately available without doing <TT
CLASS="COMMAND"
>SET ROLE</TT
>.
   </P
><P
>    <CODE
CLASS="FUNCTION"
>row_security_active</CODE
> checks whether row level
    security is active for the specified table in the context of the
    <CODE
CLASS="FUNCTION"
>current_user</CODE
> and environment. The table can
    be specified by name or by OID.
   </P
><P
>   <A
HREF="functions-info.html#FUNCTIONS-INFO-SCHEMA-TABLE"
>Table 9-59</A
> shows functions that
   determine whether a certain object is <I
CLASS="FIRSTTERM"
>visible</I
> in the
   current schema search path.
   For example, a table is said to be visible if its
   containing schema is in the search path and no table of the same
   name appears earlier in the search path.  This is equivalent to the
   statement that the table can be referenced by name without explicit
   schema qualification.  To list the names of all visible tables:
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);</PRE
><P>
  </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-INFO-SCHEMA-TABLE"
></A
><P
><B
>Table 9-59. Schema Visibility Inquiry Functions</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>Name</TH
><TH
>Return Type</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_collation_is_visible(<TT
CLASS="PARAMETER"
>collation_oid</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>is collation visible in search path</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_conversion_is_visible(<TT
CLASS="PARAMETER"
>conversion_oid</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>is conversion visible in search path</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_function_is_visible(<TT
CLASS="PARAMETER"
>function_oid</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>is function visible in search path</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_opclass_is_visible(<TT
CLASS="PARAMETER"
>opclass_oid</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>is operator class visible in search path</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_operator_is_visible(<TT
CLASS="PARAMETER"
>operator_oid</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>is operator visible in search path</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_opfamily_is_visible(<TT
CLASS="PARAMETER"
>opclass_oid</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>is operator family visible in search path</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_table_is_visible(<TT
CLASS="PARAMETER"
>table_oid</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>is table visible in search path</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_ts_config_is_visible(<TT
CLASS="PARAMETER"
>config_oid</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>is text search configuration visible in search path</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_ts_dict_is_visible(<TT
CLASS="PARAMETER"
>dict_oid</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>is text search dictionary visible in search path</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_ts_parser_is_visible(<TT
CLASS="PARAMETER"
>parser_oid</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>is text search parser visible in search path</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_ts_template_is_visible(<TT
CLASS="PARAMETER"
>template_oid</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>is text search template visible in search path</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_type_is_visible(<TT
CLASS="PARAMETER"
>type_oid</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>is type (or domain) visible in search path</TD
></TR
></TBODY
></TABLE
></DIV
><P
>    Each function performs the visibility check for one type of database
    object.  Note that <CODE
CLASS="FUNCTION"
>pg_table_is_visible</CODE
> can also be used
    with views, materialized views, indexes, sequences and foreign tables;
    <CODE
CLASS="FUNCTION"
>pg_type_is_visible</CODE
> can also be used with domains.
    For functions and operators, an object in
    the search path is visible if there is no object of the same name
    <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>and argument data type(s)</I
></SPAN
> earlier in the path.  For operator
    classes, both name and associated index access method are considered.
   </P
><P
>    All these functions require object OIDs to identify the object to be
    checked.  If you want to test an object by name, it is convenient to use
    the OID alias types (<TT
CLASS="TYPE"
>regclass</TT
>, <TT
CLASS="TYPE"
>regtype</TT
>,
    <TT
CLASS="TYPE"
>regprocedure</TT
>, <TT
CLASS="TYPE"
>regoperator</TT
>, <TT
CLASS="TYPE"
>regconfig</TT
>,
    or <TT
CLASS="TYPE"
>regdictionary</TT
>),
    for example:
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT pg_type_is_visible('myschema.widget'::regtype);</PRE
><P>
    Note that it would not make much sense to test a non-schema-qualified
    type name in this way &mdash; if the name can be recognized at all, it must be visible.
   </P
><P
>   <A
HREF="functions-info.html#FUNCTIONS-INFO-CATALOG-TABLE"
>Table 9-60</A
> lists functions that
   extract information from the system catalogs.
  </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-INFO-CATALOG-TABLE"
></A
><P
><B
>Table 9-60. System Catalog Information Functions</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>Name</TH
><TH
>Return Type</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>format_type(<TT
CLASS="PARAMETER"
>type_oid</TT
>, <TT
CLASS="PARAMETER"
>typemod</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>get SQL name of a data type</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_get_constraintdef(<TT
CLASS="PARAMETER"
>constraint_oid</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>get definition of a constraint</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_get_constraintdef(<TT
CLASS="PARAMETER"
>constraint_oid</TT
>, <TT
CLASS="PARAMETER"
>pretty_bool</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>get definition of a constraint</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_get_expr(<TT
CLASS="PARAMETER"
>pg_node_tree</TT
>, <TT
CLASS="PARAMETER"
>relation_oid</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>decompile internal form of an expression, assuming that any Vars
       in it refer to the relation indicated by the second parameter</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_get_expr(<TT
CLASS="PARAMETER"
>pg_node_tree</TT
>, <TT
CLASS="PARAMETER"
>relation_oid</TT
>, <TT
CLASS="PARAMETER"
>pretty_bool</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>decompile internal form of an expression, assuming that any Vars
       in it refer to the relation indicated by the second parameter</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_get_functiondef(<TT
CLASS="PARAMETER"
>func_oid</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>get definition of a function</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_get_function_arguments(<TT
CLASS="PARAMETER"
>func_oid</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>get argument list of function's definition (with default values)</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_get_function_identity_arguments(<TT
CLASS="PARAMETER"
>func_oid</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>get argument list to identify a function (without default values)</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_get_function_result(<TT
CLASS="PARAMETER"
>func_oid</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>get <TT
CLASS="LITERAL"
>RETURNS</TT
> clause for function</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_get_indexdef(<TT
CLASS="PARAMETER"
>index_oid</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>get <TT
CLASS="COMMAND"
>CREATE INDEX</TT
> command for index</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_get_indexdef(<TT
CLASS="PARAMETER"
>index_oid</TT
>, <TT
CLASS="PARAMETER"
>column_no</TT
>, <TT
CLASS="PARAMETER"
>pretty_bool</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>get <TT
CLASS="COMMAND"
>CREATE INDEX</TT
> command for index,
       or definition of just one index column when
       <TT
CLASS="PARAMETER"
>column_no</TT
> is not zero</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_get_keywords()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>setof record</TT
></TD
><TD
>get list of SQL keywords and their categories</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_get_ruledef(<TT
CLASS="PARAMETER"
>rule_oid</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>get <TT
CLASS="COMMAND"
>CREATE RULE</TT
> command for rule</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_get_ruledef(<TT
CLASS="PARAMETER"
>rule_oid</TT
>, <TT
CLASS="PARAMETER"
>pretty_bool</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>get <TT
CLASS="COMMAND"
>CREATE RULE</TT
> command for rule</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_get_serial_sequence(<TT
CLASS="PARAMETER"
>table_name</TT
>, <TT
CLASS="PARAMETER"
>column_name</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>get name of the sequence that a <TT
CLASS="TYPE"
>serial</TT
>, <TT
CLASS="TYPE"
>smallserial</TT
> or <TT
CLASS="TYPE"
>bigserial</TT
> column
       uses</TD
></TR
><TR
><TD
><CODE
CLASS="FUNCTION"
>pg_get_triggerdef</CODE
>(<TT
CLASS="PARAMETER"
>trigger_oid</TT
>)</TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>get <TT
CLASS="COMMAND"
>CREATE [ CONSTRAINT ] TRIGGER</TT
> command for trigger</TD
></TR
><TR
><TD
><CODE
CLASS="FUNCTION"
>pg_get_triggerdef</CODE
>(<TT
CLASS="PARAMETER"
>trigger_oid</TT
>, <TT
CLASS="PARAMETER"
>pretty_bool</TT
>)</TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>get <TT
CLASS="COMMAND"
>CREATE [ CONSTRAINT ] TRIGGER</TT
> command for trigger</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_get_userbyid(<TT
CLASS="PARAMETER"
>role_oid</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>get role name with given OID</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_get_viewdef(<TT
CLASS="PARAMETER"
>view_name</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>get underlying <TT
CLASS="COMMAND"
>SELECT</TT
> command for view or materialized view (<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>deprecated</I
></SPAN
>)</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_get_viewdef(<TT
CLASS="PARAMETER"
>view_name</TT
>, <TT
CLASS="PARAMETER"
>pretty_bool</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>get underlying <TT
CLASS="COMMAND"
>SELECT</TT
> command for view or materialized view (<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>deprecated</I
></SPAN
>)</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_get_viewdef(<TT
CLASS="PARAMETER"
>view_oid</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>get underlying <TT
CLASS="COMMAND"
>SELECT</TT
> command for view or materialized view</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_get_viewdef(<TT
CLASS="PARAMETER"
>view_oid</TT
>, <TT
CLASS="PARAMETER"
>pretty_bool</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>get underlying <TT
CLASS="COMMAND"
>SELECT</TT
> command for view or materialized view</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_get_viewdef(<TT
CLASS="PARAMETER"
>view_oid</TT
>, <TT
CLASS="PARAMETER"
>wrap_column_int</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>get underlying <TT
CLASS="COMMAND"
>SELECT</TT
> command for view or
              materialized view; lines with fields are wrapped to specified
              number of columns, pretty-printing is implied</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_options_to_table(<TT
CLASS="PARAMETER"
>reloptions</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>setof record</TT
></TD
><TD
>get the set of storage option name/value pairs</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_tablespace_databases(<TT
CLASS="PARAMETER"
>tablespace_oid</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>setof oid</TT
></TD
><TD
>get the set of database OIDs that have objects in the tablespace</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_tablespace_location(<TT
CLASS="PARAMETER"
>tablespace_oid</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>get the path in the file system that this tablespace is located in</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_typeof(<TT
CLASS="PARAMETER"
>any</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>regtype</TT
></TD
><TD
>get the data type of any value</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>collation for (<TT
CLASS="PARAMETER"
>any</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>get the collation of the argument</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>to_regclass(<TT
CLASS="PARAMETER"
>rel_name</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>regclass</TT
></TD
><TD
>get the OID of the named relation</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>to_regproc(<TT
CLASS="PARAMETER"
>func_name</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>regproc</TT
></TD
><TD
>get the OID of the named function</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>to_regprocedure(<TT
CLASS="PARAMETER"
>func_name</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>regprocedure</TT
></TD
><TD
>get the OID of the named function</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>to_regoper(<TT
CLASS="PARAMETER"
>operator_name</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>regoper</TT
></TD
><TD
>get the OID of the named operator</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>to_regoperator(<TT
CLASS="PARAMETER"
>operator_name</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>regoperator</TT
></TD
><TD
>get the OID of the named operator</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>to_regtype(<TT
CLASS="PARAMETER"
>type_name</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>regtype</TT
></TD
><TD
>get the OID of the named type</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>to_regnamespace(<TT
CLASS="PARAMETER"
>schema_name</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>regnamespace</TT
></TD
><TD
>get the OID of the named schema</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>to_regrole(<TT
CLASS="PARAMETER"
>role_name</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>regrole</TT
></TD
><TD
>get the OID of the named role</TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <CODE
CLASS="FUNCTION"
>format_type</CODE
> returns the SQL name of a data type that
   is identified by its type OID and possibly a type modifier.  Pass NULL
   for the type modifier if no specific modifier is known.
  </P
><P
>   <CODE
CLASS="FUNCTION"
>pg_get_keywords</CODE
> returns a set of records describing
   the SQL keywords recognized by the server. The <TT
CLASS="STRUCTFIELD"
>word</TT
> column
   contains the keyword.  The <TT
CLASS="STRUCTFIELD"
>catcode</TT
> column contains a
   category code: <TT
CLASS="LITERAL"
>U</TT
> for unreserved, <TT
CLASS="LITERAL"
>C</TT
> for column name,
   <TT
CLASS="LITERAL"
>T</TT
> for type or function name, or <TT
CLASS="LITERAL"
>R</TT
> for reserved.
   The <TT
CLASS="STRUCTFIELD"
>catdesc</TT
> column contains a possibly-localized string
   describing the category.
  </P
><P
>   <CODE
CLASS="FUNCTION"
>pg_get_constraintdef</CODE
>,
   <CODE
CLASS="FUNCTION"
>pg_get_indexdef</CODE
>, <CODE
CLASS="FUNCTION"
>pg_get_ruledef</CODE
>,
   and <CODE
CLASS="FUNCTION"
>pg_get_triggerdef</CODE
>, respectively reconstruct the
   creating command for a constraint, index, rule, or trigger. (Note that this
   is a decompiled reconstruction, not the original text of the command.)
   <CODE
CLASS="FUNCTION"
>pg_get_expr</CODE
> decompiles the internal form of an
   individual expression, such as the default value for a column.  It can be
   useful when examining the contents of system catalogs.  If the expression
   might contain Vars, specify the OID of the relation they refer to as the
   second parameter; if no Vars are expected, zero is sufficient.
   <CODE
CLASS="FUNCTION"
>pg_get_viewdef</CODE
> reconstructs the <TT
CLASS="COMMAND"
>SELECT</TT
>
   query that defines a view. Most of these functions come in two variants,
   one of which can optionally <SPAN
CLASS="QUOTE"
>"pretty-print"</SPAN
> the result.  The
   pretty-printed format is more readable, but the default format is more
   likely to be interpreted the same way by future versions of
   <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>; avoid using pretty-printed output for dump
   purposes.  Passing <TT
CLASS="LITERAL"
>false</TT
> for the pretty-print parameter yields
   the same result as the variant that does not have the parameter at all.
  </P
><P
>   <CODE
CLASS="FUNCTION"
>pg_get_functiondef</CODE
> returns a complete
   <TT
CLASS="COMMAND"
>CREATE OR REPLACE FUNCTION</TT
> statement for a function.
   <CODE
CLASS="FUNCTION"
>pg_get_function_arguments</CODE
> returns the argument list
   of a function, in the form it would need to appear in within
   <TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
>.
   <CODE
CLASS="FUNCTION"
>pg_get_function_result</CODE
> similarly returns the
   appropriate <TT
CLASS="LITERAL"
>RETURNS</TT
> clause for the function.
   <CODE
CLASS="FUNCTION"
>pg_get_function_identity_arguments</CODE
> returns the
   argument list necessary to identify a function, in the form it
   would need to appear in within <TT
CLASS="COMMAND"
>ALTER FUNCTION</TT
>, for
   instance.  This form omits default values.
  </P
><P
>   <CODE
CLASS="FUNCTION"
>pg_get_serial_sequence</CODE
> returns the name of the
   sequence associated with a column, or NULL if no sequence is associated
   with the column.  The first input parameter is a table name with
   optional schema, and the second parameter is a column name.  Because
   the first parameter is potentially a schema and table, it is not treated
   as a double-quoted identifier, meaning it is lower cased by default,
   while the second parameter, being just a column name, is treated as
   double-quoted and has its case preserved.  The function returns a value
   suitably formatted for passing to sequence functions (see <A
HREF="functions-sequence.html"
>Section 9.16</A
>).  This association can be modified or
   removed with <TT
CLASS="COMMAND"
>ALTER SEQUENCE OWNED BY</TT
>.  (The function
   probably should have been called
   <CODE
CLASS="FUNCTION"
>pg_get_owned_sequence</CODE
>; its current name reflects the fact
   that it's typically used with <TT
CLASS="TYPE"
>serial</TT
> or <TT
CLASS="TYPE"
>bigserial</TT
>
   columns.)
  </P
><P
>   <CODE
CLASS="FUNCTION"
>pg_get_userbyid</CODE
> extracts a role's name given
   its OID.
  </P
><P
>   <CODE
CLASS="FUNCTION"
>pg_options_to_table</CODE
> returns the set of storage
   option name/value pairs
   (<TT
CLASS="LITERAL"
>option_name</TT
>/<TT
CLASS="LITERAL"
>option_value</TT
>) when passed
   <TT
CLASS="STRUCTNAME"
>pg_class</TT
>.<TT
CLASS="STRUCTFIELD"
>reloptions</TT
> or
   <TT
CLASS="STRUCTNAME"
>pg_attribute</TT
>.<TT
CLASS="STRUCTFIELD"
>attoptions</TT
>.
  </P
><P
>   <CODE
CLASS="FUNCTION"
>pg_tablespace_databases</CODE
> allows a tablespace to be
   examined. It returns the set of OIDs of databases that have objects stored
   in the tablespace. If this function returns any rows, the tablespace is not
   empty and cannot be dropped. To display the specific objects populating the
   tablespace, you will need to connect to the databases identified by
   <CODE
CLASS="FUNCTION"
>pg_tablespace_databases</CODE
> and query their
   <TT
CLASS="STRUCTNAME"
>pg_class</TT
> catalogs.
  </P
><P
>   <CODE
CLASS="FUNCTION"
>pg_typeof</CODE
> returns the OID of the data type of the
   value that is passed to it.  This can be helpful for troubleshooting or
   dynamically constructing SQL queries.  The function is declared as
   returning <TT
CLASS="TYPE"
>regtype</TT
>, which is an OID alias type (see
   <A
HREF="datatype-oid.html"
>Section 8.18</A
>); this means that it is the same as an
   OID for comparison purposes but displays as a type name.  For example:
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT pg_typeof(33);

 pg_typeof 
-----------
 integer
(1 row)

SELECT typlen FROM pg_type WHERE oid = pg_typeof(33);
 typlen 
--------
      4
(1 row)</PRE
><P>
  </P
><P
>   The expression <TT
CLASS="LITERAL"
>collation for</TT
> returns the collation of the
   value that is passed to it.  Example:
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT collation for (description) FROM pg_description LIMIT 1;
 pg_collation_for 
------------------
 "default"
(1 row)

SELECT collation for ('foo' COLLATE "de_DE");
 pg_collation_for 
------------------
 "de_DE"
(1 row)</PRE
><P>
  The value might be quoted and schema-qualified.  If no collation is derived
  for the argument expression, then a null value is returned.  If the argument
  is not of a collatable data type, then an error is raised.
  </P
><P
>   The <CODE
CLASS="FUNCTION"
>to_regclass</CODE
>, <CODE
CLASS="FUNCTION"
>to_regproc</CODE
>,
   <CODE
CLASS="FUNCTION"
>to_regprocedure</CODE
>, <CODE
CLASS="FUNCTION"
>to_regoper</CODE
>,
   <CODE
CLASS="FUNCTION"
>to_regoperator</CODE
>, <CODE
CLASS="FUNCTION"
>to_regtype</CODE
>,
   <CODE
CLASS="FUNCTION"
>to_regnamespace</CODE
>, and <CODE
CLASS="FUNCTION"
>to_regrole</CODE
>
   functions translate relation, function, operator, type, schema, and role
   names to objects of
   type <TT
CLASS="TYPE"
>regclass</TT
>, <TT
CLASS="TYPE"
>regproc</TT
>, <TT
CLASS="TYPE"
>regprocedure</TT
>,
   <TT
CLASS="TYPE"
>regoper</TT
>, <TT
CLASS="TYPE"
>regoperator</TT
>, <TT
CLASS="TYPE"
>regtype</TT
>,
   <TT
CLASS="TYPE"
>regnamespace</TT
>, and <TT
CLASS="TYPE"
>regrole</TT
>
   respectively.  These functions differ from a cast from
   text in that they don't accept a numeric OID, and that they return null
   rather than throwing an error if the name is not found (or, for
   <CODE
CLASS="FUNCTION"
>to_regproc</CODE
> and <CODE
CLASS="FUNCTION"
>to_regoper</CODE
>, if
   the given name matches multiple objects).
  </P
><P
>   <A
HREF="functions-info.html#FUNCTIONS-INFO-OBJECT-TABLE"
>Table 9-61</A
> lists functions related to
   database object identification and addressing.
  </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-INFO-OBJECT-TABLE"
></A
><P
><B
>Table 9-61. Object Information and Addressing Functions</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>Name</TH
><TH
>Return Type</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_describe_object(<TT
CLASS="PARAMETER"
>catalog_id</TT
>, <TT
CLASS="PARAMETER"
>object_id</TT
>, <TT
CLASS="PARAMETER"
>object_sub_id</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>get description of a database object</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_identify_object(<TT
CLASS="PARAMETER"
>catalog_id</TT
> <TT
CLASS="TYPE"
>oid</TT
>, <TT
CLASS="PARAMETER"
>object_id</TT
> <TT
CLASS="TYPE"
>oid</TT
>, <TT
CLASS="PARAMETER"
>object_sub_id</TT
> <TT
CLASS="TYPE"
>integer</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="PARAMETER"
>type</TT
> <TT
CLASS="TYPE"
>text</TT
>, <TT
CLASS="PARAMETER"
>schema</TT
> <TT
CLASS="TYPE"
>text</TT
>, <TT
CLASS="PARAMETER"
>name</TT
> <TT
CLASS="TYPE"
>text</TT
>, <TT
CLASS="PARAMETER"
>identity</TT
> <TT
CLASS="TYPE"
>text</TT
></TD
><TD
>get identity of a database object</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_identify_object_as_address(<TT
CLASS="PARAMETER"
>catalog_id</TT
> <TT
CLASS="TYPE"
>oid</TT
>, <TT
CLASS="PARAMETER"
>object_id</TT
> <TT
CLASS="TYPE"
>oid</TT
>, <TT
CLASS="PARAMETER"
>object_sub_id</TT
> <TT
CLASS="TYPE"
>integer</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="PARAMETER"
>type</TT
> <TT
CLASS="TYPE"
>text</TT
>, <TT
CLASS="PARAMETER"
>name</TT
> <TT
CLASS="TYPE"
>text[]</TT
>, <TT
CLASS="PARAMETER"
>args</TT
> <TT
CLASS="TYPE"
>text[]</TT
></TD
><TD
>get external representation of a database object's address</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_get_object_address(<TT
CLASS="PARAMETER"
>type</TT
> <TT
CLASS="TYPE"
>text</TT
>, <TT
CLASS="PARAMETER"
>name</TT
> <TT
CLASS="TYPE"
>text[]</TT
>, <TT
CLASS="PARAMETER"
>args</TT
> <TT
CLASS="TYPE"
>text[]</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="PARAMETER"
>catalog_id</TT
> <TT
CLASS="TYPE"
>oid</TT
>, <TT
CLASS="PARAMETER"
>object_id</TT
> <TT
CLASS="TYPE"
>oid</TT
>, <TT
CLASS="PARAMETER"
>object_sub_id</TT
> <TT
CLASS="TYPE"
>int32</TT
></TD
><TD
>get address of a database object, from its external representation</TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <CODE
CLASS="FUNCTION"
>pg_describe_object</CODE
> returns a textual description of a database
   object specified by catalog OID, object OID and a (possibly zero) sub-object ID.
   This description is intended to be human-readable, and might be translated,
   depending on server configuration.
   This is useful to determine the identity of an object as stored in the
   <TT
CLASS="STRUCTNAME"
>pg_depend</TT
> catalog.
  </P
><P
>   <CODE
CLASS="FUNCTION"
>pg_identify_object</CODE
> returns a row containing enough information
   to uniquely identify the database object specified by catalog OID, object OID and a
   (possibly zero) sub-object ID.  This information is intended to be machine-readable,
   and is never translated.
   <TT
CLASS="PARAMETER"
>type</TT
> identifies the type of database object;
   <TT
CLASS="PARAMETER"
>schema</TT
> is the schema name that the object belongs in, or
   <TT
CLASS="LITERAL"
>NULL</TT
> for object types that do not belong to schemas;
   <TT
CLASS="PARAMETER"
>name</TT
> is the name of the object, quoted if necessary, only
   present if it can be used (alongside schema name, if pertinent) as a unique
   identifier of the object, otherwise <TT
CLASS="LITERAL"
>NULL</TT
>;
   <TT
CLASS="PARAMETER"
>identity</TT
> is the complete object identity, with the precise format
   depending on object type, and each part within the format being
   schema-qualified and quoted as necessary.
  </P
><P
>   <CODE
CLASS="FUNCTION"
>pg_identify_object_as_address</CODE
> returns a row containing
   enough information to uniquely identify the database object specified by
   catalog OID, object OID and a (possibly zero) sub-object ID.  The returned
   information is independent of the current server, that is, it could be used
   to identify an identically named object in another server.
   <TT
CLASS="PARAMETER"
>type</TT
> identifies the type of database object;
   <TT
CLASS="PARAMETER"
>name</TT
> and <TT
CLASS="PARAMETER"
>args</TT
> are text arrays that together
   form a reference to the object.  These three columns can be passed to
   <CODE
CLASS="FUNCTION"
>pg_get_object_address</CODE
> to obtain the internal address
   of the object.
   This function is the inverse of <CODE
CLASS="FUNCTION"
>pg_get_object_address</CODE
>.
  </P
><P
>   <CODE
CLASS="FUNCTION"
>pg_get_object_address</CODE
> returns a row containing enough
   information to uniquely identify the database object specified by its
   type and object name and argument arrays.  The returned values are the
   ones that would be used in system catalogs such as <TT
CLASS="STRUCTNAME"
>pg_depend</TT
>
   and can be passed to other system functions such as
   <CODE
CLASS="FUNCTION"
>pg_identify_object</CODE
> or <CODE
CLASS="FUNCTION"
>pg_describe_object</CODE
>.
   <TT
CLASS="PARAMETER"
>catalog_id</TT
> is the OID of the system catalog containing the
   object;
   <TT
CLASS="PARAMETER"
>object_id</TT
> is the OID of the object itself, and
   <TT
CLASS="PARAMETER"
>object_sub_id</TT
> is the object sub-ID, or zero if none.
   This function is the inverse of <CODE
CLASS="FUNCTION"
>pg_identify_object_as_address</CODE
>.
  </P
><P
>    The functions shown in <A
HREF="functions-info.html#FUNCTIONS-INFO-COMMENT-TABLE"
>Table 9-62</A
>
    extract comments previously stored with the <A
HREF="sql-comment.html"
>COMMENT</A
>
    command.  A null value is returned if no
    comment could be found for the specified parameters.
   </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-INFO-COMMENT-TABLE"
></A
><P
><B
>Table 9-62. Comment Information Functions</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>Name</TH
><TH
>Return Type</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>col_description(<TT
CLASS="PARAMETER"
>table_oid</TT
>, <TT
CLASS="PARAMETER"
>column_number</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>get comment for a table column</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>obj_description(<TT
CLASS="PARAMETER"
>object_oid</TT
>, <TT
CLASS="PARAMETER"
>catalog_name</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>get comment for a database object</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>obj_description(<TT
CLASS="PARAMETER"
>object_oid</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>get comment for a database object (<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>deprecated</I
></SPAN
>)</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>shobj_description(<TT
CLASS="PARAMETER"
>object_oid</TT
>, <TT
CLASS="PARAMETER"
>catalog_name</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>get comment for a shared database object</TD
></TR
></TBODY
></TABLE
></DIV
><P
>    <CODE
CLASS="FUNCTION"
>col_description</CODE
> returns the comment for a table
    column, which is specified by the OID of its table and its column number.
    (<CODE
CLASS="FUNCTION"
>obj_description</CODE
> cannot be used for table columns
    since columns do not have OIDs of their own.)
   </P
><P
>    The two-parameter form of <CODE
CLASS="FUNCTION"
>obj_description</CODE
> returns the
    comment for a database object specified by its OID and the name of the
    containing system catalog.  For example,
    <TT
CLASS="LITERAL"
>obj_description(123456,'pg_class')</TT
>
    would retrieve the comment for the table with OID 123456.
    The one-parameter form of <CODE
CLASS="FUNCTION"
>obj_description</CODE
> requires only
    the object OID.  It is deprecated since there is no guarantee that
    OIDs are unique across different system catalogs; therefore, the wrong
    comment might be returned.
   </P
><P
>    <CODE
CLASS="FUNCTION"
>shobj_description</CODE
> is used just like
    <CODE
CLASS="FUNCTION"
>obj_description</CODE
> except it is used for retrieving
    comments on shared objects.  Some system catalogs are global to all
    databases within each cluster, and the descriptions for objects in them
    are stored globally as well.
   </P
><P
>    The functions shown in <A
HREF="functions-info.html#FUNCTIONS-TXID-SNAPSHOT"
>Table 9-63</A
>
    provide server transaction information in an exportable form.  The main
    use of these functions is to determine which transactions were committed
    between two snapshots.
   </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-TXID-SNAPSHOT"
></A
><P
><B
>Table 9-63. Transaction IDs and Snapshots</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>Name</TH
><TH
>Return Type</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>txid_current()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>get current transaction ID, assigning a new one if the current transaction does not have one</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>txid_current_snapshot()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>txid_snapshot</TT
></TD
><TD
>get current snapshot</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>txid_snapshot_xip(<TT
CLASS="PARAMETER"
>txid_snapshot</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>setof bigint</TT
></TD
><TD
>get in-progress transaction IDs in snapshot</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>txid_snapshot_xmax(<TT
CLASS="PARAMETER"
>txid_snapshot</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>get <TT
CLASS="LITERAL"
>xmax</TT
> of snapshot</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>txid_snapshot_xmin(<TT
CLASS="PARAMETER"
>txid_snapshot</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>get <TT
CLASS="LITERAL"
>xmin</TT
> of snapshot</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>txid_visible_in_snapshot(<TT
CLASS="PARAMETER"
>bigint</TT
>, <TT
CLASS="PARAMETER"
>txid_snapshot</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>is transaction ID visible in snapshot? (do not use with subtransaction ids)</TD
></TR
></TBODY
></TABLE
></DIV
><P
>    The internal transaction ID type (<TT
CLASS="TYPE"
>xid</TT
>) is 32 bits wide and
    wraps around every 4 billion transactions.  However, these functions
    export a 64-bit format that is extended with an <SPAN
CLASS="QUOTE"
>"epoch"</SPAN
> counter
    so it will not wrap around during the life of an installation.
    The data type used by these functions, <TT
CLASS="TYPE"
>txid_snapshot</TT
>,
    stores information about transaction ID
    visibility at a particular moment in time.  Its components are
    described in <A
HREF="functions-info.html#FUNCTIONS-TXID-SNAPSHOT-PARTS"
>Table 9-64</A
>.
   </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-TXID-SNAPSHOT-PARTS"
></A
><P
><B
>Table 9-64. Snapshot Components</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>Name</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="TYPE"
>xmin</TT
></TD
><TD
>         Earliest transaction ID (txid) that is still active.  All earlier
         transactions will either be committed and visible, or rolled
         back and dead.
       </TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>xmax</TT
></TD
><TD
>        First as-yet-unassigned txid.  All txids greater than or equal to this
        are not yet started as of the time of the snapshot, and thus invisible.
       </TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>xip_list</TT
></TD
><TD
>        Active txids at the time of the snapshot.  The list
        includes only those active txids between <TT
CLASS="LITERAL"
>xmin</TT
>
        and <TT
CLASS="LITERAL"
>xmax</TT
>; there might be active txids higher
        than <TT
CLASS="LITERAL"
>xmax</TT
>.  A txid that is <TT
CLASS="LITERAL"
>xmin &lt;= txid &lt;
        xmax</TT
> and not in this list was already completed
        at the time of the snapshot, and thus either visible or
        dead according to its commit status.  The list does not
        include txids of subtransactions.
       </TD
></TR
></TBODY
></TABLE
></DIV
><P
>    <TT
CLASS="TYPE"
>txid_snapshot</TT
>'s textual representation is
    <TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>xmin</I
></TT
>:<TT
CLASS="REPLACEABLE"
><I
>xmax</I
></TT
>:<TT
CLASS="REPLACEABLE"
><I
>xip_list</I
></TT
></TT
>.
    For example <TT
CLASS="LITERAL"
>10:20:10,14,15</TT
> means
    <TT
CLASS="LITERAL"
>xmin=10, xmax=20, xip_list=10, 14, 15</TT
>.
   </P
><P
>    The functions shown in <A
HREF="functions-info.html#FUNCTIONS-COMMIT-TIMESTAMP"
>Table 9-65</A
>
    provide information about transactions that have been already committed.
    These functions mainly provide information about when the transactions
    were committed. They only provide useful data when
    <A
HREF="runtime-config-replication.html#GUC-TRACK-COMMIT-TIMESTAMP"
>track_commit_timestamp</A
> configuration option is enabled
    and only for transactions that were committed after it was enabled.
   </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-COMMIT-TIMESTAMP"
></A
><P
><B
>Table 9-65. Committed transaction information</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>Name</TH
><TH
>Return Type</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_xact_commit_timestamp(<TT
CLASS="PARAMETER"
>xid</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>get commit timestamp of a transaction</TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_last_committed_xact()</CODE
></TT
>
       </TD
><TD
><TT
CLASS="PARAMETER"
>xid</TT
> <TT
CLASS="TYPE"
>xid</TT
>, <TT
CLASS="PARAMETER"
>timestamp</TT
> <TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>get transaction ID and commit timestamp of latest committed transaction</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="functions-srf.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="functions-admin.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Set Returning Functions</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="functions.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>System Administration Functions</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>